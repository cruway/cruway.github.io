1. 根本Entityとして分割
Joinは'RDBMS'の花と言う。なぜJoinがRDBMSの花なのかを確認しよう。

- Joinを使用しない場合のデータアクセスの量：280MB
- Joinを使用する場合のデータアクセスの量：60MB + 115KB = 略 60MB

結局、テーブルデータをすべてサクセスする場合はJoinを使用しない構造でアクセスするデータ量は60MBで、Joinを使用しない
場合はアクセスをするデータ量に比べて倍以上アクセスするデータ量が減少する。

性能はアクセスをするデータ量と比例してJoinを使用する場合がもっと早い性能を保証できるのは事実である。もちろん、
Joinを利用する場合がアクセスするデータ量は60MBで、Joinを使用しない場合と比べてアクセス量は4倍以上減少するが、
使用するJoinの方式によりJoin負荷が発生する。

二つ目は少ないデータでアクセスする場合はどうでしょ？Jonを使用しない場合とJoinを使用する場合を分離して差異を確認しよう。

- Joinを使用しない場合：ランダムアクセスが発生しない。
- Joinを使用する場合：ランダムアクセスが発生。

少ないデータをアクセスする場合、Joinを使ったらランダムアクセスが発生してその量が多かったら性能が低下する。しかし、
少ないデータをアクセスする場合はランダムアクセスも少なく発生して、Joinが最適化ができたら性能低下が発生しなくなる。

そしてJoinの最適化を通じてアクセスするランダムアクセスの量を減少ができる。ランダムアクセスの発生は性能を低下
するが、これは十分にSQL最適化で解決できる。

このようにJoinは効果的に使うとテーブルのデータを減少して性能を保証できる。そして、重複データを除去することができて
データの整合性が保証される。

このような理由でRDBMSでJoinは花と呼ぶ。もちろん、間違えたJoinは想像を超える性能低下を発生させることを覚える必要がある。

結局、根本Entity分割はデータ整合性及び全体データベースの大きさ減少のため必要である。でもJoinに関する性能低下に
関してはSQL最適化を行う必要がある。

「表1」Entity分割による現象
・オンライン処理
  - 統合Entity：有利
  - Subset分離Entity：不利
  - 備考：根本EntityのAttribute抽出し、Join発生で性能低下が可能

・バッチ処理
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：根本Entityに分割する場合、大きさが小さくなって有利

・業務柔軟性(Subset別)
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：別途のEntity
  
・業務柔軟性(全体)
  
・管理
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：個別作業可能
  
・保存空間
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：コードで具現

・Data整合性
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：重複データ存在

・業務分析
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：Entity Nameで区分可能
  

1) オンライン処理：根本Entity分割はオンライン業務処理しはJoinして照会を行う必要があって不利になり。統合Entity
の場合はオンライン処理を行う場合利用しなくても有利になる。

2) バッチ処理：バッチ処理の時、根本Entityで分割する場合がEntityのサイズが小さくなり有利になる。

3) 業務柔軟性(Entity別)：Entity別で業務が変わる場合、該当Entityだけ修正すればいいので根本Entityで分離する場合が
有利になる。

4) 業務柔軟性(全体)：全体業務柔軟性は根本Entityで分離することとは関係がないので二つすべて同一する。

5) 管理：根本Entityで分離する場合はデータと分離して作業が可能になるので根本Entityを分離する場合がもっと有利になる。

6) 保存空間：根本Entityで分離する場合Entityの大きさが減少して保存空間は減少する。

7) Data整合性：根本Entityで分離する場合、重複データを除去して性能は向上する。

8) 業務分析：根本Entityにより、分離Entityの場合Entityが分離ができていて有利になる。

根本Entityとしての分離は統合Entityに比べて長所が多い、Entity分割が有利になり、音来院処理に関してSQL最適化は
必ず必要な段階である。

【表1 統合Entityと中心Entityの分離】
・オンライン処理
  - 備考：業務により、異なる。履歴でーあまでは照会する場合は、分離が不利。

・バッチ処理
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：Data減少及び個別作業は可能。

・業務柔軟性(Entity別)
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：別途のEntity
  
・業務柔軟性(全体)
  
・管理
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：個別作業可能
  
・保存空間
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：Entityの大きさ減少可能。

・Data整合性
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：重複データ除去し、Data整合性強化

・業務分析
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：Entity Nameで区分可能
  
  上記より、中心Entityに関する分離の長所が多いがオンライン処理で問題が発生する場合、Entity分離をしないことと
  オンライン処理に関する最適な方法が提示されるべき。
 
 
 2. 1:1 OR 0 分割
 0分割はJoinが発生しなければ性能に有利である。1:1 OR 0 分割はJoin増加とOuter Join及びFull Outer Joinが発生する
 可能性が高くなり、これは性能を低下させる。そして生まれが同じEntityは垂直分割をしたので整合性には不利となる。
 
 例えば、国民目録まではよく紹介して国民内容はあまり照会しない場合、1:1 OR 0分割を考慮し 1:1 OR 0 分割を行うなら
 二つのテーブルをJoinする場合Outer Joinは行う可能性が高い。Outer Joinは実行計画が固定されて柔軟性がなくなる。
 
 一般的にJoinを行い (+)がないEntityをまずアクセスをするので、各自のEntityは必ず必要なIndexが決める。もし、該当
 Indexが存在しない場合、性能低下が発生する。
 
 -オンライン処理：1:1 OR 0 分割し、Joinがよく発生したら性能低下になり、発生しなければオンライン処理し性能は向上になる。
 
 - バッチ処理：バッチ処理し、1:1 OR 0 分割をする場合が個別的にバッチ処理を行うので有利になる。
 
 - 業務柔軟性(Entity別)：Entity別で業務が変わる場合、該当Entityだけ修正すればいいので1:1 OR 0 分割を行う場合が有利になる。
 
 - 業務柔軟性(全体)：すべての業務柔軟性は二つすべて同一する。
 
 - 管理：1:1 OR 0分割は同一なEntityを垂直分割することで保存空間は二つすべて同一する。
 
 - Data整合性：1:1 OR 0分割は同一なEntityを垂直分割することでData整合性に問題が発生する可能性がある。
 
 - 業務分析：1:1 OR 0分割は同一なEntityを垂直分割することで業務分析には不利になる。
 
 【表1 統合Entityと1:1 OR 0Entityの分離】
・オンライン処理
  - 備考：Join発生でEntity分離が不利

・バッチ処理
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：個別作業は可能。

・業務柔軟性(Entity別)
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：別途のEntity
  
・業務柔軟性(全体)
  
・管理
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：個別作業可能
  
・保存空間

・Data整合性
  - 統合Entity：不利
  - Subset分離Entity：有利
  - 備考：生成が同一なDataの分離

・業務分析

上記みたいに 1:1 OR 0分割の探勝は多くなるかもしれないし、Joinがよく発生したら1:1 OR 0分割を行わないほうが有利になる。
1:1 OR 0分割の後、Joinをよく使用しなければならない状況ならSQL最適化をする必要がある。
